<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>prometheus_fastapi_instrumentator.metrics API documentation</title>
<meta name="description" content="This module contains ready-to-use functions that can be passed on to the
instrumentator instance with the `add()` method. The idea behind this is to
…" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>prometheus_fastapi_instrumentator.metrics</code></h1>
</header>
<section id="section-intro">
<p>This module contains ready-to-use functions that can be passed on to the
instrumentator instance with the <code>add()</code> method. The idea behind this is to
make the types of metrics you want to export with the instrumentation easily
customizable. The default instrumentation function <code><a title="prometheus_fastapi_instrumentator.metrics.default" href="#prometheus_fastapi_instrumentator.metrics.default">default()</a></code> can also be found
here.</p>
<p>If your requirements are really specific or very extensive it makes sense to
create your own instrumentation function instead of combining several functions
from this module.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright © 2020 Tim Schwenke &lt;tim.and.trallnag+code@gmail.com&gt;
# Licensed under Apache License 2.0 &lt;http://www.apache.org/licenses/LICENSE-2.0&gt;

&#34;&#34;&#34;
This module contains ready-to-use functions that can be passed on to the
instrumentator instance with the `add()` method. The idea behind this is to
make the types of metrics you want to export with the instrumentation easily
customizable. The default instrumentation function `default` can also be found
here.

If your requirements are really specific or very extensive it makes sense to
create your own instrumentation function instead of combining several functions
from this module.
&#34;&#34;&#34;

from typing import Callable, Optional, Tuple

from prometheus_client import Counter, Histogram, Summary
from starlette.requests import Request
from starlette.responses import Response

# ==============================================================================


class Info:
    def __init__(
        self,
        request: Request,
        response: Optional[Response],
        method: str,
        modified_handler: str,
        modified_status: str,
        modified_duration: float,
    ):
        &#34;&#34;&#34;Creates Info object that is used for instrumentation functions.

        This is the only argument that is passed to the instrumentation functions.

        Args:
            request (Request): Python Requests request object.
            response (Response or None): Python Requests response object.
            method (str): Unmodified method of the request.
            modified_handler (str): Handler representation after processing by
                instrumentator. For example grouped to `none` if not templated.
            modified_status (str): Status code representation after processing
                by instrumentator. For example grouping into `2xx`, `3xx` and so on.
            modified_duration (float): Latency representation after processing
                by instrumentator. For example rounding of decimals. Seconds.
        &#34;&#34;&#34;

        self.request = request
        self.response = response
        self.method = method
        self.modified_handler = modified_handler
        self.modified_status = modified_status
        self.modified_duration = modified_duration


def _build_label_attribute_names(
    should_include_handler: bool,
    should_include_method: bool,
    should_include_status: bool,
) -&gt; Tuple[list, list]:
    &#34;&#34;&#34;Builds up tuple with to be used label and attribute names.

    Args:
        should_include_handler (bool): Should the `handler` label be part of the metric?
        should_include_method (bool): Should the `method` label be part of the metric?
        should_include_status (bool): Should the `status` label be part of the metric?

    Returns:
        Tuple with two list elements.

        First element: List with all labels to be used.
        Second element: List with all attribute names to be used from the
            `Info` object. Done like this to enable dynamic on / off of labels.
    &#34;&#34;&#34;

    label_names = []
    info_attribute_names = []

    if should_include_handler:
        label_names.append(&#34;handler&#34;)
        info_attribute_names.append(&#34;modified_handler&#34;)

    if should_include_method:
        label_names.append(&#34;method&#34;)
        info_attribute_names.append(&#34;method&#34;)

    if should_include_status:
        label_names.append(&#34;status&#34;)
        info_attribute_names.append(&#34;modified_status&#34;)

    return label_names, info_attribute_names


# ==============================================================================
# Instrumentation / Metrics functions


def latency(
    metric_name: str = &#34;http_request_duration_seconds&#34;,
    metric_doc: str = &#34;Duration of HTTP requests in seconds&#34;,
    metric_namespace: str = &#34;&#34;,
    metric_subsystem: str = &#34;&#34;,
    should_include_handler: bool = True,
    should_include_method: bool = True,
    should_include_status: bool = True,
    buckets: tuple = Histogram.DEFAULT_BUCKETS,
) -&gt; Callable[[Info], None]:
    &#34;&#34;&#34;Default metric for the Prometheus FastAPI Instrumentator.

    Args:
        metric_name (str, optional): Name of the metric to be created. Must be
            unique. Defaults to &#34;http_request_duration_seconds&#34;.

        metric_doc (str, optional): Documentation of the metric. Defaults to
            &#34;Duration of HTTP requests in seconds&#34;.

        metric_namespace (str, optional): Namespace of all  metrics in this
            metric function. Defaults to &#34;&#34;.

        metric_subsystem (str, optional): Subsystem of all  metrics in this
            metric function. Defaults to &#34;&#34;.

        should_include_handler: Should the `handler` label be part of the
            metric? Defaults to `True`.

        should_include_method: Should the `method` label be part of the
            metric? Defaults to `True`.

        should_include_status: Should the `status` label be part of the
            metric? Defaults to `True`.

        buckets: Buckets for the histogram. Defaults to Prometheus default.
            Defaults to default buckets from Prometheus client library.

    Returns:
        Function that takes a single parameter `Info`.
    &#34;&#34;&#34;

    if buckets[-1] != float(&#34;inf&#34;):
        buckets = buckets + (float(&#34;inf&#34;),)

    label_names, info_attribute_names = _build_label_attribute_names(
        should_include_handler, should_include_method, should_include_status
    )

    if label_names:
        METRIC = Histogram(
            metric_name,
            metric_doc,
            labelnames=label_names,
            buckets=buckets,
            namespace=metric_namespace,
            subsystem=metric_subsystem,
        )
    else:
        METRIC = Histogram(
            metric_name,
            metric_doc,
            buckets=buckets,
            namespace=metric_namespace,
            subsystem=metric_subsystem,
        )

    def instrumentation(info: Info) -&gt; None:
        if label_names:
            label_values = []
            for attribute_name in info_attribute_names:
                label_values.append(getattr(info, attribute_name))
            METRIC.labels(*label_values).observe(info.modified_duration)
        else:
            METRIC.observe(info.modified_duration)

    return instrumentation


# ------------------------------------------------------------------------------


def request_size(
    metric_name: str = &#34;http_request_size_bytes&#34;,
    metric_doc: str = &#34;Content bytes of requests.&#34;,
    metric_namespace: str = &#34;&#34;,
    metric_subsystem: str = &#34;&#34;,
    should_include_handler: bool = True,
    should_include_method: bool = True,
    should_include_status: bool = True,
) -&gt; Callable[[Info], None]:
    &#34;&#34;&#34;Record the content length of incoming requests.

    If content length is missing 0 will be assumed.

    Args:
        metric_name (str, optional): Name of the metric to be created. Must be
            unique. Defaults to &#34;http_request_size_bytes&#34;.
        metric_doc (str, optional): Documentation of the metric. Defaults to
            &#34;Content bytes of requests.&#34;.
        metric_namespace (str, optional): Namespace of all  metrics in this
            metric function. Defaults to &#34;&#34;.
        metric_subsystem (str, optional): Subsystem of all  metrics in this
            metric function. Defaults to &#34;&#34;.
        should_include_handler: Should the `handler` label be part of the
            metric? Defaults to `True`.
        should_include_method: Should the `method` label be part of the
            metric? Defaults to `True`.
        should_include_status: Should the `status` label be part of the metric?
            Defaults to `True`.

    Returns:
        Function that takes a single parameter `Info`.
    &#34;&#34;&#34;

    label_names, info_attribute_names = _build_label_attribute_names(
        should_include_handler, should_include_method, should_include_status
    )

    if label_names:
        METRIC = Summary(
            metric_name,
            metric_doc,
            labelnames=label_names,
            namespace=metric_namespace,
            subsystem=metric_subsystem,
        )
    else:
        METRIC = Summary(
            metric_name,
            metric_doc,
            namespace=metric_namespace,
            subsystem=metric_subsystem,
        )

    def instrumentation(info: Info) -&gt; None:
        content_length = info.request.headers.get(&#34;Content-Length&#34;, 0)
        if label_names:
            label_values = []
            for attribute_name in info_attribute_names:
                label_values.append(getattr(info, attribute_name))
            METRIC.labels(*label_values).observe(int(content_length))
        else:
            METRIC.observe(int(content_length))

    return instrumentation


# ------------------------------------------------------------------------------


def response_size(
    metric_name: str = &#34;http_response_size_bytes&#34;,
    metric_doc: str = &#34;Content bytes of responses.&#34;,
    metric_namespace: str = &#34;&#34;,
    metric_subsystem: str = &#34;&#34;,
    should_include_handler: bool = True,
    should_include_method: bool = True,
    should_include_status: bool = True,
) -&gt; Callable[[Info], None]:
    &#34;&#34;&#34;Record the content length of outgoing responses.

    If content length is missing 0 will be assumed.

    Args:
        metric_name (str, optional): Name of the metric to be created. Must be
            unique. Defaults to &#34;http_response_size_bytes&#34;.

        metric_doc (str, optional): Documentation of the metric. Defaults to
            &#34;Content bytes of responses.&#34;.

        metric_namespace (str, optional): Namespace of all  metrics in this
            metric function. Defaults to &#34;&#34;.

        metric_subsystem (str, optional): Subsystem of all  metrics in this
            metric function. Defaults to &#34;&#34;.

        should_include_handler: Should the `handler` label be part of the
            metric? Defaults to `True`.

        should_include_method: Should the `method` label be part of the metric?
            Defaults to `True`.

        should_include_status: Should the `status` label be part of the metric?
            Defaults to `True`.

    Returns:
        Function that takes a single parameter `Info`.
    &#34;&#34;&#34;

    label_names, info_attribute_names = _build_label_attribute_names(
        should_include_handler, should_include_method, should_include_status
    )

    if label_names:
        METRIC = Summary(
            metric_name,
            metric_doc,
            labelnames=label_names,
            namespace=metric_namespace,
            subsystem=metric_subsystem,
        )
    else:
        METRIC = Summary(
            metric_name,
            metric_doc,
            namespace=metric_namespace,
            subsystem=metric_subsystem,
        )

    def instrumentation(info: Info) -&gt; None:
        if info.response and hasattr(info.response, &#34;headers&#34;):
            content_length = info.response.headers.get(&#34;Content-Length&#34;, 0)
        else:
            content_length = 0

        if label_names:
            label_values = []
            for attribute_name in info_attribute_names:
                label_values.append(getattr(info, attribute_name))
            METRIC.labels(*label_values).observe(int(content_length))
        else:
            METRIC.observe(int(content_length))

    return instrumentation


# ------------------------------------------------------------------------------


def combined_size(
    metric_name: str = &#34;http_combined_size_bytes&#34;,
    metric_doc: str = &#34;Content bytes of requests and responses.&#34;,
    metric_namespace: str = &#34;&#34;,
    metric_subsystem: str = &#34;&#34;,
    should_include_handler: bool = True,
    should_include_method: bool = True,
    should_include_status: bool = True,
) -&gt; Callable[[Info], None]:
    &#34;&#34;&#34;Record the combined content length of requests and responses.

    If content length is missing 0 will be assumed.

    Args:
        metric_name (str, optional): Name of the metric to be created. Must be
            unique. Defaults to &#34;http_combined_size_bytes&#34;.

        metric_doc (str, optional): Documentation of the metric. Defaults to
            &#34;Content bytes of requests and responses.&#34;.

        metric_namespace (str, optional): Namespace of all  metrics in this
            metric function. Defaults to &#34;&#34;.

        metric_subsystem (str, optional): Subsystem of all  metrics in this
            metric function. Defaults to &#34;&#34;.

        should_include_handler: Should the `handler` label be part of the
            metric? Defaults to `True`.

        should_include_method: Should the `method` label be part of the metric?
            Defaults to `True`.

        should_include_status: Should the `status` label be part of the metric?
            Defaults to `True`.

    Returns:
        Function that takes a single parameter `Info`.
    &#34;&#34;&#34;

    label_names, info_attribute_names = _build_label_attribute_names(
        should_include_handler, should_include_method, should_include_status
    )

    if label_names:
        METRIC = Summary(
            metric_name,
            metric_doc,
            labelnames=label_names,
            namespace=metric_namespace,
            subsystem=metric_subsystem,
        )
    else:
        METRIC = Summary(
            metric_name,
            metric_doc,
            namespace=metric_namespace,
            subsystem=metric_subsystem,
        )

    def instrumentation(info: Info) -&gt; None:
        request_cl = info.request.headers.get(&#34;Content-Length&#34;, 0)

        if info.response and hasattr(info.response, &#34;headers&#34;):
            response_cl = info.response.headers.get(&#34;Content-Length&#34;, 0)
        else:
            response_cl = 0

        content_length = int(request_cl) + int(response_cl)

        if label_names:
            label_values = []
            for attribute_name in info_attribute_names:
                label_values.append(getattr(info, attribute_name))
            METRIC.labels(*label_values).observe(int(content_length))
        else:
            METRIC.observe(int(content_length))

    return instrumentation


# ------------------------------------------------------------------------------


def requests(
    metric_name: str = &#34;http_requests_total&#34;,
    metric_doc: str = &#34;Total number of requests by method, status and handler.&#34;,
    metric_namespace: str = &#34;&#34;,
    metric_subsystem: str = &#34;&#34;,
    should_include_handler: bool = True,
    should_include_method: bool = True,
    should_include_status: bool = True,
) -&gt; Callable[[Info], None]:
    &#34;&#34;&#34;Record the number of requests.

    Args:
        metric_name (str, optional): Name of the metric to be created. Must
            be unique. Defaults to &#34;http_requests_total&#34;.

        metric_doc (str, optional): Documentation of the metric. Defaults to
            &#34;Total number of requests by method, status and handler.&#34;.

        metric_namespace (str, optional): Namespace of all  metrics in this
            metric function. Defaults to &#34;&#34;.

        metric_subsystem (str, optional): Subsystem of all  metrics in this
            metric function. Defaults to &#34;&#34;.

        should_include_handler (bool, optional): Should the `handler` label
            be part of the metric? Defaults to `True`.

        should_include_method (bool, optional): Should the `method` label be
            part of the metric? Defaults to `True`.

        should_include_status (bool, optional): Should the `status` label be
            part of the metric? Defaults to `True`.

    Returns:
        Function that takes a single parameter `Info`.
    &#34;&#34;&#34;

    label_names, info_attribute_names = _build_label_attribute_names(
        should_include_handler, should_include_method, should_include_status
    )

    if label_names:
        METRIC = Counter(
            metric_name,
            metric_doc,
            labelnames=label_names,
            namespace=metric_namespace,
            subsystem=metric_subsystem,
        )
    else:
        METRIC = Counter(
            metric_name,
            metric_doc,
            namespace=metric_namespace,
            subsystem=metric_subsystem,
        )

    def instrumentation(info: Info) -&gt; None:
        if label_names:
            label_values = []
            for attribute_name in info_attribute_names:
                label_values.append(getattr(info, attribute_name))
            METRIC.labels(*label_values).inc()
        else:
            METRIC.inc()

    return instrumentation


# ------------------------------------------------------------------------------


def default(
    metric_namespace: str = &#34;&#34;,
    metric_subsystem: str = &#34;&#34;,
    should_only_respect_2xx_for_highr: bool = False,
    latency_highr_buckets: tuple = (
        0.01,
        0.025,
        0.05,
        0.075,
        0.1,
        0.25,
        0.5,
        0.75,
        1,
        1.5,
        2,
        2.5,
        3,
        3.5,
        4,
        4.5,
        5,
        7.5,
        10,
        30,
        60,
    ),
    latency_lowr_buckets: tuple = (0.1, 0.5, 1),
) -&gt; Callable[[Info], None]:
    &#34;&#34;&#34;Contains multiple metrics to cover multiple things.

    Combines several metrics into a single function. Also more efficient than
    multiple separate instrumentation functions that do more or less the same.

    You get the following:

    * `http_requests_total` (`handler`, `status`, `method`): Total number of
        requests by handler, status and method.
    * `http_request_size_bytes` (`handler`): Total number of incoming
        content length bytes by handler.
    * `http_response_size_bytes` (`handler`): Total number of outgoing
        content length bytes by handler.
    * `http_request_duration_highr_seconds` (no labels): High number of buckets
        leading to more accurate calculation of percentiles.
    * `http_request_duration_seconds` (`handler`):
        Kepp the bucket count very low. Only put in SLIs.

    Args:
        metric_namespace (str, optional): Namespace of all  metrics in this
            metric function. Defaults to &#34;&#34;.

        metric_subsystem (str, optional): Subsystem of all  metrics in this
            metric function. Defaults to &#34;&#34;.

        should_only_respect_2xx_for_highr (str, optional): Should the metric
            `http_request_duration_highr_seconds` only include latencies of
            requests / responses that have a status code starting with `2`?
            Defaults to `False`.

        latency_highr_buckets (tuple[float], optional): Buckets tuple for high
            res histogram. Can be large because no labels are used. Defaults to
            (0.01, 0.025, 0.05, 0.075, 0.1, 0.25, 0.5, 0.75, 1, 1.5, 2, 2.5,
            3, 3.5, 4, 4.5, 5, 7.5, 10, 30, 60).

        latency_lowr_buckets (tuple[float], optional): Buckets tuple for low
            res histogram. Should be very small as all possible labels are
            included. Defaults to `(0.1, 0.5, 1)`.

    Returns:
        Function that takes a single parameter `Info`.
    &#34;&#34;&#34;

    if latency_highr_buckets[-1] != float(&#34;inf&#34;):
        latency_highr_buckets = latency_highr_buckets + (float(&#34;inf&#34;),)

    if latency_lowr_buckets[-1] != float(&#34;inf&#34;):
        latency_lowr_buckets = latency_lowr_buckets + (float(&#34;inf&#34;),)

    TOTAL = Counter(
        name=&#34;http_requests_total&#34;,
        documentation=&#34;Total number of requests by method, status and handler.&#34;,
        labelnames=(
            &#34;method&#34;,
            &#34;status&#34;,
            &#34;handler&#34;,
        ),
        namespace=metric_namespace,
        subsystem=metric_subsystem,
    )

    IN_SIZE = Summary(
        name=&#34;http_request_size_bytes&#34;,
        documentation=(
            &#34;Content length of incoming requests by handler. &#34;
            &#34;Only value of header is respected. Otherwise ignored. &#34;
            &#34;No percentile calculated. &#34;
        ),
        labelnames=(&#34;handler&#34;,),
        namespace=metric_namespace,
        subsystem=metric_subsystem,
    )

    OUT_SIZE = Summary(
        name=&#34;http_response_size_bytes&#34;,
        documentation=(
            &#34;Content length of outgoing responses by handler. &#34;
            &#34;Only value of header is respected. Otherwise ignored. &#34;
            &#34;No percentile calculated. &#34;
        ),
        labelnames=(&#34;handler&#34;,),
        namespace=metric_namespace,
        subsystem=metric_subsystem,
    )

    LATENCY_HIGHR = Histogram(
        name=&#34;http_request_duration_highr_seconds&#34;,
        documentation=(
            &#34;Latency with many buckets but no API specific labels. &#34;
            &#34;Made for more accurate percentile calculations. &#34;
        ),
        buckets=latency_highr_buckets,
        namespace=metric_namespace,
        subsystem=metric_subsystem,
    )

    LATENCY_LOWR = Histogram(
        name=&#34;http_request_duration_seconds&#34;,
        documentation=(
            &#34;Latency with only few buckets by handler. &#34;
            &#34;Made to be only used if aggregation by handler is important. &#34;
        ),
        buckets=latency_lowr_buckets,
        labelnames=(&#34;handler&#34;,),
        namespace=metric_namespace,
        subsystem=metric_subsystem,
    )

    def instrumentation(info: Info) -&gt; None:
        TOTAL.labels(info.method, info.modified_status, info.modified_handler).inc()

        IN_SIZE.labels(info.modified_handler).observe(
            int(info.request.headers.get(&#34;Content-Length&#34;, 0))
        )

        if info.response and hasattr(info.response, &#34;headers&#34;):
            OUT_SIZE.labels(info.modified_handler).observe(
                int(info.response.headers.get(&#34;Content-Length&#34;, 0))
            )
        else:
            OUT_SIZE.labels(info.modified_handler).observe(0)

        if not should_only_respect_2xx_for_highr or info.modified_status.startswith(&#34;2&#34;):
            LATENCY_HIGHR.observe(info.modified_duration)

        LATENCY_LOWR.labels(info.modified_handler).observe(info.modified_duration)

    return instrumentation


# ==============================================================================</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="prometheus_fastapi_instrumentator.metrics.combined_size"><code class="name flex">
<span>def <span class="ident">combined_size</span></span>(<span>metric_name: str = 'http_combined_size_bytes', metric_doc: str = 'Content bytes of requests and responses.', metric_namespace: str = '', metric_subsystem: str = '', should_include_handler: bool = True, should_include_method: bool = True, should_include_status: bool = True) ‑> Callable[[<a title="prometheus_fastapi_instrumentator.metrics.Info" href="#prometheus_fastapi_instrumentator.metrics.Info">Info</a>], NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Record the combined content length of requests and responses.</p>
<p>If content length is missing 0 will be assumed.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>metric_name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of the metric to be created. Must be
unique. Defaults to "http_combined_size_bytes".</dd>
<dt><strong><code>metric_doc</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Documentation of the metric. Defaults to
"Content bytes of requests and responses.".</dd>
<dt><strong><code>metric_namespace</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Namespace of all
metrics in this
metric function. Defaults to "".</dd>
<dt><strong><code>metric_subsystem</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Subsystem of all
metrics in this
metric function. Defaults to "".</dd>
<dt><strong><code>should_include_handler</code></strong></dt>
<dd>Should the <code>handler</code> label be part of the
metric? Defaults to <code>True</code>.</dd>
<dt><strong><code>should_include_method</code></strong></dt>
<dd>Should the <code>method</code> label be part of the metric?
Defaults to <code>True</code>.</dd>
<dt><strong><code>should_include_status</code></strong></dt>
<dd>Should the <code>status</code> label be part of the metric?
Defaults to <code>True</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Function that takes a single parameter <code><a title="prometheus_fastapi_instrumentator.metrics.Info" href="#prometheus_fastapi_instrumentator.metrics.Info">Info</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combined_size(
    metric_name: str = &#34;http_combined_size_bytes&#34;,
    metric_doc: str = &#34;Content bytes of requests and responses.&#34;,
    metric_namespace: str = &#34;&#34;,
    metric_subsystem: str = &#34;&#34;,
    should_include_handler: bool = True,
    should_include_method: bool = True,
    should_include_status: bool = True,
) -&gt; Callable[[Info], None]:
    &#34;&#34;&#34;Record the combined content length of requests and responses.

    If content length is missing 0 will be assumed.

    Args:
        metric_name (str, optional): Name of the metric to be created. Must be
            unique. Defaults to &#34;http_combined_size_bytes&#34;.

        metric_doc (str, optional): Documentation of the metric. Defaults to
            &#34;Content bytes of requests and responses.&#34;.

        metric_namespace (str, optional): Namespace of all  metrics in this
            metric function. Defaults to &#34;&#34;.

        metric_subsystem (str, optional): Subsystem of all  metrics in this
            metric function. Defaults to &#34;&#34;.

        should_include_handler: Should the `handler` label be part of the
            metric? Defaults to `True`.

        should_include_method: Should the `method` label be part of the metric?
            Defaults to `True`.

        should_include_status: Should the `status` label be part of the metric?
            Defaults to `True`.

    Returns:
        Function that takes a single parameter `Info`.
    &#34;&#34;&#34;

    label_names, info_attribute_names = _build_label_attribute_names(
        should_include_handler, should_include_method, should_include_status
    )

    if label_names:
        METRIC = Summary(
            metric_name,
            metric_doc,
            labelnames=label_names,
            namespace=metric_namespace,
            subsystem=metric_subsystem,
        )
    else:
        METRIC = Summary(
            metric_name,
            metric_doc,
            namespace=metric_namespace,
            subsystem=metric_subsystem,
        )

    def instrumentation(info: Info) -&gt; None:
        request_cl = info.request.headers.get(&#34;Content-Length&#34;, 0)

        if info.response and hasattr(info.response, &#34;headers&#34;):
            response_cl = info.response.headers.get(&#34;Content-Length&#34;, 0)
        else:
            response_cl = 0

        content_length = int(request_cl) + int(response_cl)

        if label_names:
            label_values = []
            for attribute_name in info_attribute_names:
                label_values.append(getattr(info, attribute_name))
            METRIC.labels(*label_values).observe(int(content_length))
        else:
            METRIC.observe(int(content_length))

    return instrumentation</code></pre>
</details>
</dd>
<dt id="prometheus_fastapi_instrumentator.metrics.default"><code class="name flex">
<span>def <span class="ident">default</span></span>(<span>metric_namespace: str = '', metric_subsystem: str = '', should_only_respect_2xx_for_highr: bool = False, latency_highr_buckets: tuple = (0.01, 0.025, 0.05, 0.075, 0.1, 0.25, 0.5, 0.75, 1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5, 7.5, 10, 30, 60), latency_lowr_buckets: tuple = (0.1, 0.5, 1)) ‑> Callable[[<a title="prometheus_fastapi_instrumentator.metrics.Info" href="#prometheus_fastapi_instrumentator.metrics.Info">Info</a>], NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Contains multiple metrics to cover multiple things.</p>
<p>Combines several metrics into a single function. Also more efficient than
multiple separate instrumentation functions that do more or less the same.</p>
<p>You get the following:</p>
<ul>
<li><code>http_requests_total</code> (<code>handler</code>, <code>status</code>, <code>method</code>): Total number of
requests by handler, status and method.</li>
<li><code>http_request_size_bytes</code> (<code>handler</code>): Total number of incoming
content length bytes by handler.</li>
<li><code>http_response_size_bytes</code> (<code>handler</code>): Total number of outgoing
content length bytes by handler.</li>
<li><code>http_request_duration_highr_seconds</code> (no labels): High number of buckets
leading to more accurate calculation of percentiles.</li>
<li><code>http_request_duration_seconds</code> (<code>handler</code>):
Kepp the bucket count very low. Only put in SLIs.</li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>metric_namespace</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Namespace of all
metrics in this
metric function. Defaults to "".</dd>
<dt><strong><code>metric_subsystem</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Subsystem of all
metrics in this
metric function. Defaults to "".</dd>
<dt><strong><code>should_only_respect_2xx_for_highr</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Should the metric
<code>http_request_duration_highr_seconds</code> only include latencies of
requests / responses that have a status code starting with <code>2</code>?
Defaults to <code>False</code>.</dd>
<dt><strong><code>latency_highr_buckets</code></strong> :&ensp;<code>tuple[float]</code>, optional</dt>
<dd>Buckets tuple for high
res histogram. Can be large because no labels are used. Defaults to
(0.01, 0.025, 0.05, 0.075, 0.1, 0.25, 0.5, 0.75, 1, 1.5, 2, 2.5,
3, 3.5, 4, 4.5, 5, 7.5, 10, 30, 60).</dd>
<dt><strong><code>latency_lowr_buckets</code></strong> :&ensp;<code>tuple[float]</code>, optional</dt>
<dd>Buckets tuple for low
res histogram. Should be very small as all possible labels are
included. Defaults to <code>(0.1, 0.5, 1)</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Function that takes a single parameter <code><a title="prometheus_fastapi_instrumentator.metrics.Info" href="#prometheus_fastapi_instrumentator.metrics.Info">Info</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def default(
    metric_namespace: str = &#34;&#34;,
    metric_subsystem: str = &#34;&#34;,
    should_only_respect_2xx_for_highr: bool = False,
    latency_highr_buckets: tuple = (
        0.01,
        0.025,
        0.05,
        0.075,
        0.1,
        0.25,
        0.5,
        0.75,
        1,
        1.5,
        2,
        2.5,
        3,
        3.5,
        4,
        4.5,
        5,
        7.5,
        10,
        30,
        60,
    ),
    latency_lowr_buckets: tuple = (0.1, 0.5, 1),
) -&gt; Callable[[Info], None]:
    &#34;&#34;&#34;Contains multiple metrics to cover multiple things.

    Combines several metrics into a single function. Also more efficient than
    multiple separate instrumentation functions that do more or less the same.

    You get the following:

    * `http_requests_total` (`handler`, `status`, `method`): Total number of
        requests by handler, status and method.
    * `http_request_size_bytes` (`handler`): Total number of incoming
        content length bytes by handler.
    * `http_response_size_bytes` (`handler`): Total number of outgoing
        content length bytes by handler.
    * `http_request_duration_highr_seconds` (no labels): High number of buckets
        leading to more accurate calculation of percentiles.
    * `http_request_duration_seconds` (`handler`):
        Kepp the bucket count very low. Only put in SLIs.

    Args:
        metric_namespace (str, optional): Namespace of all  metrics in this
            metric function. Defaults to &#34;&#34;.

        metric_subsystem (str, optional): Subsystem of all  metrics in this
            metric function. Defaults to &#34;&#34;.

        should_only_respect_2xx_for_highr (str, optional): Should the metric
            `http_request_duration_highr_seconds` only include latencies of
            requests / responses that have a status code starting with `2`?
            Defaults to `False`.

        latency_highr_buckets (tuple[float], optional): Buckets tuple for high
            res histogram. Can be large because no labels are used. Defaults to
            (0.01, 0.025, 0.05, 0.075, 0.1, 0.25, 0.5, 0.75, 1, 1.5, 2, 2.5,
            3, 3.5, 4, 4.5, 5, 7.5, 10, 30, 60).

        latency_lowr_buckets (tuple[float], optional): Buckets tuple for low
            res histogram. Should be very small as all possible labels are
            included. Defaults to `(0.1, 0.5, 1)`.

    Returns:
        Function that takes a single parameter `Info`.
    &#34;&#34;&#34;

    if latency_highr_buckets[-1] != float(&#34;inf&#34;):
        latency_highr_buckets = latency_highr_buckets + (float(&#34;inf&#34;),)

    if latency_lowr_buckets[-1] != float(&#34;inf&#34;):
        latency_lowr_buckets = latency_lowr_buckets + (float(&#34;inf&#34;),)

    TOTAL = Counter(
        name=&#34;http_requests_total&#34;,
        documentation=&#34;Total number of requests by method, status and handler.&#34;,
        labelnames=(
            &#34;method&#34;,
            &#34;status&#34;,
            &#34;handler&#34;,
        ),
        namespace=metric_namespace,
        subsystem=metric_subsystem,
    )

    IN_SIZE = Summary(
        name=&#34;http_request_size_bytes&#34;,
        documentation=(
            &#34;Content length of incoming requests by handler. &#34;
            &#34;Only value of header is respected. Otherwise ignored. &#34;
            &#34;No percentile calculated. &#34;
        ),
        labelnames=(&#34;handler&#34;,),
        namespace=metric_namespace,
        subsystem=metric_subsystem,
    )

    OUT_SIZE = Summary(
        name=&#34;http_response_size_bytes&#34;,
        documentation=(
            &#34;Content length of outgoing responses by handler. &#34;
            &#34;Only value of header is respected. Otherwise ignored. &#34;
            &#34;No percentile calculated. &#34;
        ),
        labelnames=(&#34;handler&#34;,),
        namespace=metric_namespace,
        subsystem=metric_subsystem,
    )

    LATENCY_HIGHR = Histogram(
        name=&#34;http_request_duration_highr_seconds&#34;,
        documentation=(
            &#34;Latency with many buckets but no API specific labels. &#34;
            &#34;Made for more accurate percentile calculations. &#34;
        ),
        buckets=latency_highr_buckets,
        namespace=metric_namespace,
        subsystem=metric_subsystem,
    )

    LATENCY_LOWR = Histogram(
        name=&#34;http_request_duration_seconds&#34;,
        documentation=(
            &#34;Latency with only few buckets by handler. &#34;
            &#34;Made to be only used if aggregation by handler is important. &#34;
        ),
        buckets=latency_lowr_buckets,
        labelnames=(&#34;handler&#34;,),
        namespace=metric_namespace,
        subsystem=metric_subsystem,
    )

    def instrumentation(info: Info) -&gt; None:
        TOTAL.labels(info.method, info.modified_status, info.modified_handler).inc()

        IN_SIZE.labels(info.modified_handler).observe(
            int(info.request.headers.get(&#34;Content-Length&#34;, 0))
        )

        if info.response and hasattr(info.response, &#34;headers&#34;):
            OUT_SIZE.labels(info.modified_handler).observe(
                int(info.response.headers.get(&#34;Content-Length&#34;, 0))
            )
        else:
            OUT_SIZE.labels(info.modified_handler).observe(0)

        if not should_only_respect_2xx_for_highr or info.modified_status.startswith(&#34;2&#34;):
            LATENCY_HIGHR.observe(info.modified_duration)

        LATENCY_LOWR.labels(info.modified_handler).observe(info.modified_duration)

    return instrumentation</code></pre>
</details>
</dd>
<dt id="prometheus_fastapi_instrumentator.metrics.latency"><code class="name flex">
<span>def <span class="ident">latency</span></span>(<span>metric_name: str = 'http_request_duration_seconds', metric_doc: str = 'Duration of HTTP requests in seconds', metric_namespace: str = '', metric_subsystem: str = '', should_include_handler: bool = True, should_include_method: bool = True, should_include_status: bool = True, buckets: tuple = (0.005, 0.01, 0.025, 0.05, 0.075, 0.1, 0.25, 0.5, 0.75, 1.0, 2.5, 5.0, 7.5, 10.0, inf)) ‑> Callable[[<a title="prometheus_fastapi_instrumentator.metrics.Info" href="#prometheus_fastapi_instrumentator.metrics.Info">Info</a>], NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Default metric for the Prometheus FastAPI Instrumentator.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>metric_name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of the metric to be created. Must be
unique. Defaults to "http_request_duration_seconds".</dd>
<dt><strong><code>metric_doc</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Documentation of the metric. Defaults to
"Duration of HTTP requests in seconds".</dd>
<dt><strong><code>metric_namespace</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Namespace of all
metrics in this
metric function. Defaults to "".</dd>
<dt><strong><code>metric_subsystem</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Subsystem of all
metrics in this
metric function. Defaults to "".</dd>
<dt><strong><code>should_include_handler</code></strong></dt>
<dd>Should the <code>handler</code> label be part of the
metric? Defaults to <code>True</code>.</dd>
<dt><strong><code>should_include_method</code></strong></dt>
<dd>Should the <code>method</code> label be part of the
metric? Defaults to <code>True</code>.</dd>
<dt><strong><code>should_include_status</code></strong></dt>
<dd>Should the <code>status</code> label be part of the
metric? Defaults to <code>True</code>.</dd>
<dt><strong><code>buckets</code></strong></dt>
<dd>Buckets for the histogram. Defaults to Prometheus default.
Defaults to default buckets from Prometheus client library.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Function that takes a single parameter <code><a title="prometheus_fastapi_instrumentator.metrics.Info" href="#prometheus_fastapi_instrumentator.metrics.Info">Info</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def latency(
    metric_name: str = &#34;http_request_duration_seconds&#34;,
    metric_doc: str = &#34;Duration of HTTP requests in seconds&#34;,
    metric_namespace: str = &#34;&#34;,
    metric_subsystem: str = &#34;&#34;,
    should_include_handler: bool = True,
    should_include_method: bool = True,
    should_include_status: bool = True,
    buckets: tuple = Histogram.DEFAULT_BUCKETS,
) -&gt; Callable[[Info], None]:
    &#34;&#34;&#34;Default metric for the Prometheus FastAPI Instrumentator.

    Args:
        metric_name (str, optional): Name of the metric to be created. Must be
            unique. Defaults to &#34;http_request_duration_seconds&#34;.

        metric_doc (str, optional): Documentation of the metric. Defaults to
            &#34;Duration of HTTP requests in seconds&#34;.

        metric_namespace (str, optional): Namespace of all  metrics in this
            metric function. Defaults to &#34;&#34;.

        metric_subsystem (str, optional): Subsystem of all  metrics in this
            metric function. Defaults to &#34;&#34;.

        should_include_handler: Should the `handler` label be part of the
            metric? Defaults to `True`.

        should_include_method: Should the `method` label be part of the
            metric? Defaults to `True`.

        should_include_status: Should the `status` label be part of the
            metric? Defaults to `True`.

        buckets: Buckets for the histogram. Defaults to Prometheus default.
            Defaults to default buckets from Prometheus client library.

    Returns:
        Function that takes a single parameter `Info`.
    &#34;&#34;&#34;

    if buckets[-1] != float(&#34;inf&#34;):
        buckets = buckets + (float(&#34;inf&#34;),)

    label_names, info_attribute_names = _build_label_attribute_names(
        should_include_handler, should_include_method, should_include_status
    )

    if label_names:
        METRIC = Histogram(
            metric_name,
            metric_doc,
            labelnames=label_names,
            buckets=buckets,
            namespace=metric_namespace,
            subsystem=metric_subsystem,
        )
    else:
        METRIC = Histogram(
            metric_name,
            metric_doc,
            buckets=buckets,
            namespace=metric_namespace,
            subsystem=metric_subsystem,
        )

    def instrumentation(info: Info) -&gt; None:
        if label_names:
            label_values = []
            for attribute_name in info_attribute_names:
                label_values.append(getattr(info, attribute_name))
            METRIC.labels(*label_values).observe(info.modified_duration)
        else:
            METRIC.observe(info.modified_duration)

    return instrumentation</code></pre>
</details>
</dd>
<dt id="prometheus_fastapi_instrumentator.metrics.request_size"><code class="name flex">
<span>def <span class="ident">request_size</span></span>(<span>metric_name: str = 'http_request_size_bytes', metric_doc: str = 'Content bytes of requests.', metric_namespace: str = '', metric_subsystem: str = '', should_include_handler: bool = True, should_include_method: bool = True, should_include_status: bool = True) ‑> Callable[[<a title="prometheus_fastapi_instrumentator.metrics.Info" href="#prometheus_fastapi_instrumentator.metrics.Info">Info</a>], NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Record the content length of incoming requests.</p>
<p>If content length is missing 0 will be assumed.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>metric_name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of the metric to be created. Must be
unique. Defaults to "http_request_size_bytes".</dd>
<dt><strong><code>metric_doc</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Documentation of the metric. Defaults to
"Content bytes of requests.".</dd>
<dt><strong><code>metric_namespace</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Namespace of all
metrics in this
metric function. Defaults to "".</dd>
<dt><strong><code>metric_subsystem</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Subsystem of all
metrics in this
metric function. Defaults to "".</dd>
<dt><strong><code>should_include_handler</code></strong></dt>
<dd>Should the <code>handler</code> label be part of the
metric? Defaults to <code>True</code>.</dd>
<dt><strong><code>should_include_method</code></strong></dt>
<dd>Should the <code>method</code> label be part of the
metric? Defaults to <code>True</code>.</dd>
<dt><strong><code>should_include_status</code></strong></dt>
<dd>Should the <code>status</code> label be part of the metric?
Defaults to <code>True</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Function that takes a single parameter <code><a title="prometheus_fastapi_instrumentator.metrics.Info" href="#prometheus_fastapi_instrumentator.metrics.Info">Info</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def request_size(
    metric_name: str = &#34;http_request_size_bytes&#34;,
    metric_doc: str = &#34;Content bytes of requests.&#34;,
    metric_namespace: str = &#34;&#34;,
    metric_subsystem: str = &#34;&#34;,
    should_include_handler: bool = True,
    should_include_method: bool = True,
    should_include_status: bool = True,
) -&gt; Callable[[Info], None]:
    &#34;&#34;&#34;Record the content length of incoming requests.

    If content length is missing 0 will be assumed.

    Args:
        metric_name (str, optional): Name of the metric to be created. Must be
            unique. Defaults to &#34;http_request_size_bytes&#34;.
        metric_doc (str, optional): Documentation of the metric. Defaults to
            &#34;Content bytes of requests.&#34;.
        metric_namespace (str, optional): Namespace of all  metrics in this
            metric function. Defaults to &#34;&#34;.
        metric_subsystem (str, optional): Subsystem of all  metrics in this
            metric function. Defaults to &#34;&#34;.
        should_include_handler: Should the `handler` label be part of the
            metric? Defaults to `True`.
        should_include_method: Should the `method` label be part of the
            metric? Defaults to `True`.
        should_include_status: Should the `status` label be part of the metric?
            Defaults to `True`.

    Returns:
        Function that takes a single parameter `Info`.
    &#34;&#34;&#34;

    label_names, info_attribute_names = _build_label_attribute_names(
        should_include_handler, should_include_method, should_include_status
    )

    if label_names:
        METRIC = Summary(
            metric_name,
            metric_doc,
            labelnames=label_names,
            namespace=metric_namespace,
            subsystem=metric_subsystem,
        )
    else:
        METRIC = Summary(
            metric_name,
            metric_doc,
            namespace=metric_namespace,
            subsystem=metric_subsystem,
        )

    def instrumentation(info: Info) -&gt; None:
        content_length = info.request.headers.get(&#34;Content-Length&#34;, 0)
        if label_names:
            label_values = []
            for attribute_name in info_attribute_names:
                label_values.append(getattr(info, attribute_name))
            METRIC.labels(*label_values).observe(int(content_length))
        else:
            METRIC.observe(int(content_length))

    return instrumentation</code></pre>
</details>
</dd>
<dt id="prometheus_fastapi_instrumentator.metrics.requests"><code class="name flex">
<span>def <span class="ident">requests</span></span>(<span>metric_name: str = 'http_requests_total', metric_doc: str = 'Total number of requests by method, status and handler.', metric_namespace: str = '', metric_subsystem: str = '', should_include_handler: bool = True, should_include_method: bool = True, should_include_status: bool = True) ‑> Callable[[<a title="prometheus_fastapi_instrumentator.metrics.Info" href="#prometheus_fastapi_instrumentator.metrics.Info">Info</a>], NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Record the number of requests.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>metric_name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of the metric to be created. Must
be unique. Defaults to "http_requests_total".</dd>
<dt><strong><code>metric_doc</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Documentation of the metric. Defaults to
"Total number of requests by method, status and handler.".</dd>
<dt><strong><code>metric_namespace</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Namespace of all
metrics in this
metric function. Defaults to "".</dd>
<dt><strong><code>metric_subsystem</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Subsystem of all
metrics in this
metric function. Defaults to "".</dd>
<dt><strong><code>should_include_handler</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Should the <code>handler</code> label
be part of the metric? Defaults to <code>True</code>.</dd>
<dt><strong><code>should_include_method</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Should the <code>method</code> label be
part of the metric? Defaults to <code>True</code>.</dd>
<dt><strong><code>should_include_status</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Should the <code>status</code> label be
part of the metric? Defaults to <code>True</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Function that takes a single parameter <code><a title="prometheus_fastapi_instrumentator.metrics.Info" href="#prometheus_fastapi_instrumentator.metrics.Info">Info</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def requests(
    metric_name: str = &#34;http_requests_total&#34;,
    metric_doc: str = &#34;Total number of requests by method, status and handler.&#34;,
    metric_namespace: str = &#34;&#34;,
    metric_subsystem: str = &#34;&#34;,
    should_include_handler: bool = True,
    should_include_method: bool = True,
    should_include_status: bool = True,
) -&gt; Callable[[Info], None]:
    &#34;&#34;&#34;Record the number of requests.

    Args:
        metric_name (str, optional): Name of the metric to be created. Must
            be unique. Defaults to &#34;http_requests_total&#34;.

        metric_doc (str, optional): Documentation of the metric. Defaults to
            &#34;Total number of requests by method, status and handler.&#34;.

        metric_namespace (str, optional): Namespace of all  metrics in this
            metric function. Defaults to &#34;&#34;.

        metric_subsystem (str, optional): Subsystem of all  metrics in this
            metric function. Defaults to &#34;&#34;.

        should_include_handler (bool, optional): Should the `handler` label
            be part of the metric? Defaults to `True`.

        should_include_method (bool, optional): Should the `method` label be
            part of the metric? Defaults to `True`.

        should_include_status (bool, optional): Should the `status` label be
            part of the metric? Defaults to `True`.

    Returns:
        Function that takes a single parameter `Info`.
    &#34;&#34;&#34;

    label_names, info_attribute_names = _build_label_attribute_names(
        should_include_handler, should_include_method, should_include_status
    )

    if label_names:
        METRIC = Counter(
            metric_name,
            metric_doc,
            labelnames=label_names,
            namespace=metric_namespace,
            subsystem=metric_subsystem,
        )
    else:
        METRIC = Counter(
            metric_name,
            metric_doc,
            namespace=metric_namespace,
            subsystem=metric_subsystem,
        )

    def instrumentation(info: Info) -&gt; None:
        if label_names:
            label_values = []
            for attribute_name in info_attribute_names:
                label_values.append(getattr(info, attribute_name))
            METRIC.labels(*label_values).inc()
        else:
            METRIC.inc()

    return instrumentation</code></pre>
</details>
</dd>
<dt id="prometheus_fastapi_instrumentator.metrics.response_size"><code class="name flex">
<span>def <span class="ident">response_size</span></span>(<span>metric_name: str = 'http_response_size_bytes', metric_doc: str = 'Content bytes of responses.', metric_namespace: str = '', metric_subsystem: str = '', should_include_handler: bool = True, should_include_method: bool = True, should_include_status: bool = True) ‑> Callable[[<a title="prometheus_fastapi_instrumentator.metrics.Info" href="#prometheus_fastapi_instrumentator.metrics.Info">Info</a>], NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Record the content length of outgoing responses.</p>
<p>If content length is missing 0 will be assumed.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>metric_name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of the metric to be created. Must be
unique. Defaults to "http_response_size_bytes".</dd>
<dt><strong><code>metric_doc</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Documentation of the metric. Defaults to
"Content bytes of responses.".</dd>
<dt><strong><code>metric_namespace</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Namespace of all
metrics in this
metric function. Defaults to "".</dd>
<dt><strong><code>metric_subsystem</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Subsystem of all
metrics in this
metric function. Defaults to "".</dd>
<dt><strong><code>should_include_handler</code></strong></dt>
<dd>Should the <code>handler</code> label be part of the
metric? Defaults to <code>True</code>.</dd>
<dt><strong><code>should_include_method</code></strong></dt>
<dd>Should the <code>method</code> label be part of the metric?
Defaults to <code>True</code>.</dd>
<dt><strong><code>should_include_status</code></strong></dt>
<dd>Should the <code>status</code> label be part of the metric?
Defaults to <code>True</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Function that takes a single parameter <code><a title="prometheus_fastapi_instrumentator.metrics.Info" href="#prometheus_fastapi_instrumentator.metrics.Info">Info</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def response_size(
    metric_name: str = &#34;http_response_size_bytes&#34;,
    metric_doc: str = &#34;Content bytes of responses.&#34;,
    metric_namespace: str = &#34;&#34;,
    metric_subsystem: str = &#34;&#34;,
    should_include_handler: bool = True,
    should_include_method: bool = True,
    should_include_status: bool = True,
) -&gt; Callable[[Info], None]:
    &#34;&#34;&#34;Record the content length of outgoing responses.

    If content length is missing 0 will be assumed.

    Args:
        metric_name (str, optional): Name of the metric to be created. Must be
            unique. Defaults to &#34;http_response_size_bytes&#34;.

        metric_doc (str, optional): Documentation of the metric. Defaults to
            &#34;Content bytes of responses.&#34;.

        metric_namespace (str, optional): Namespace of all  metrics in this
            metric function. Defaults to &#34;&#34;.

        metric_subsystem (str, optional): Subsystem of all  metrics in this
            metric function. Defaults to &#34;&#34;.

        should_include_handler: Should the `handler` label be part of the
            metric? Defaults to `True`.

        should_include_method: Should the `method` label be part of the metric?
            Defaults to `True`.

        should_include_status: Should the `status` label be part of the metric?
            Defaults to `True`.

    Returns:
        Function that takes a single parameter `Info`.
    &#34;&#34;&#34;

    label_names, info_attribute_names = _build_label_attribute_names(
        should_include_handler, should_include_method, should_include_status
    )

    if label_names:
        METRIC = Summary(
            metric_name,
            metric_doc,
            labelnames=label_names,
            namespace=metric_namespace,
            subsystem=metric_subsystem,
        )
    else:
        METRIC = Summary(
            metric_name,
            metric_doc,
            namespace=metric_namespace,
            subsystem=metric_subsystem,
        )

    def instrumentation(info: Info) -&gt; None:
        if info.response and hasattr(info.response, &#34;headers&#34;):
            content_length = info.response.headers.get(&#34;Content-Length&#34;, 0)
        else:
            content_length = 0

        if label_names:
            label_values = []
            for attribute_name in info_attribute_names:
                label_values.append(getattr(info, attribute_name))
            METRIC.labels(*label_values).observe(int(content_length))
        else:
            METRIC.observe(int(content_length))

    return instrumentation</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="prometheus_fastapi_instrumentator.metrics.Info"><code class="flex name class">
<span>class <span class="ident">Info</span></span>
<span>(</span><span>request: starlette.requests.Request, response: Optional[starlette.responses.Response], method: str, modified_handler: str, modified_status: str, modified_duration: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates Info object that is used for instrumentation functions.</p>
<p>This is the only argument that is passed to the instrumentation functions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>request</code></strong> :&ensp;<code>Request</code></dt>
<dd>Python Requests request object.</dd>
<dt><strong><code>response</code></strong> :&ensp;<code>Response</code> or <code>None</code></dt>
<dd>Python Requests response object.</dd>
<dt><strong><code>method</code></strong> :&ensp;<code>str</code></dt>
<dd>Unmodified method of the request.</dd>
<dt><strong><code>modified_handler</code></strong> :&ensp;<code>str</code></dt>
<dd>Handler representation after processing by
instrumentator. For example grouped to <code>none</code> if not templated.</dd>
<dt><strong><code>modified_status</code></strong> :&ensp;<code>str</code></dt>
<dd>Status code representation after processing
by instrumentator. For example grouping into <code>2xx</code>, <code>3xx</code> and so on.</dd>
<dt><strong><code>modified_duration</code></strong> :&ensp;<code>float</code></dt>
<dd>Latency representation after processing
by instrumentator. For example rounding of decimals. Seconds.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Info:
    def __init__(
        self,
        request: Request,
        response: Optional[Response],
        method: str,
        modified_handler: str,
        modified_status: str,
        modified_duration: float,
    ):
        &#34;&#34;&#34;Creates Info object that is used for instrumentation functions.

        This is the only argument that is passed to the instrumentation functions.

        Args:
            request (Request): Python Requests request object.
            response (Response or None): Python Requests response object.
            method (str): Unmodified method of the request.
            modified_handler (str): Handler representation after processing by
                instrumentator. For example grouped to `none` if not templated.
            modified_status (str): Status code representation after processing
                by instrumentator. For example grouping into `2xx`, `3xx` and so on.
            modified_duration (float): Latency representation after processing
                by instrumentator. For example rounding of decimals. Seconds.
        &#34;&#34;&#34;

        self.request = request
        self.response = response
        self.method = method
        self.modified_handler = modified_handler
        self.modified_status = modified_status
        self.modified_duration = modified_duration</code></pre>
</details>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="prometheus_fastapi_instrumentator" href="index.html">prometheus_fastapi_instrumentator</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="prometheus_fastapi_instrumentator.metrics.combined_size" href="#prometheus_fastapi_instrumentator.metrics.combined_size">combined_size</a></code></li>
<li><code><a title="prometheus_fastapi_instrumentator.metrics.default" href="#prometheus_fastapi_instrumentator.metrics.default">default</a></code></li>
<li><code><a title="prometheus_fastapi_instrumentator.metrics.latency" href="#prometheus_fastapi_instrumentator.metrics.latency">latency</a></code></li>
<li><code><a title="prometheus_fastapi_instrumentator.metrics.request_size" href="#prometheus_fastapi_instrumentator.metrics.request_size">request_size</a></code></li>
<li><code><a title="prometheus_fastapi_instrumentator.metrics.requests" href="#prometheus_fastapi_instrumentator.metrics.requests">requests</a></code></li>
<li><code><a title="prometheus_fastapi_instrumentator.metrics.response_size" href="#prometheus_fastapi_instrumentator.metrics.response_size">response_size</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="prometheus_fastapi_instrumentator.metrics.Info" href="#prometheus_fastapi_instrumentator.metrics.Info">Info</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>
